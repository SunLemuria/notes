一、赋值

在 Python 中，对象的赋值就是简单的对象引用，这点和 C++不同，如下所示:
a = [1,2,"hello",['python', 'C++']]
b = a
在上述情况下，a 和 b 是一样的，他们指向同一片内存，b 不过是 a 的别名，是引用。
我们可以使用 b is a 去判断，返回 True，表明他们地址相同，内容相同，也可以使用 id()函数来查看两个列表的地址是否相同。
赋值操作(包括对象作为参数、返回值)不会开辟新的内存空间，它只是复制了对象的引用。也就是 说除了 b 这个名字之外，没有其他的内存开销。
修改了a，也就影响了b，同理，修改了b，也就影响了a。

二、浅拷贝(shallow copy)

浅拷贝有三种形式:切片操作、工厂函数、copy 模块中的 copy 函数。
比如上述的列表 a

切片操作:b=a[:] 或者 b=[x for x in a]
工厂函数:b = list(a)
copy 函数:b = copy.copy(a)

集合类型记录的是引用的地址,shallow copy时集合类型地址改变,但集合中记录的引用地址不变
copy后集合中不可变类型不会互相影响, 修改一个列表中的不可变元素时, 只是将这个引用修改指向另一个位置, 不影响另一个列表
但可变类型因为在内存中只有一份, 在a中修改和在b中修改效果是一样的

三、深拷贝(deep copy)
深拷贝只有一种形式，copy 模块中的 deepcopy()函数。
深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空 间开销要高。
同样的对列表 a，如果使用 b = copy.deepcopy(a)，再修改列表 b 将不会影响到列表 a，即使嵌套的列表具有更深的层次，也不会产生任何影响，因为深拷贝拷贝出来的对象根本就是一个全新的对象， 不再与原来的对象有任何的关联。

四、拷贝的注意点
对于非容器类型，如数字、字符，以及其他的“原子”类型，没有拷贝一说，产生的都是原对象的 引用。
如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。


五、深拷贝与浅拷贝区别只在可变元素的表现上
```
l=[]
for i in xrange(10):
    l.append({‘num’:i})
```python
[{‘num’:0}，{‘num’:1}，{‘num’:2}，{‘num’:3}，{‘num’:4}，{‘num’:5}，{‘num’:6}，{‘num’:7}，{‘num’:8}， {‘num’:9}]

```
l = []
a = {'num':0}
for i in range(10):
    a['num'] = i
    l.append(a)
```python

[{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}， {‘num’:9}]

原因是:字典是可变对象，在下方的 l.append(a)的操作中是把字典 a 的引用传到列表 l 中，当后
续操作修改 a[‘num’]的值的时候，l中的值也会跟着改变，相当于浅拷贝。